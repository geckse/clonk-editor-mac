<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>
<!DOCTYPE doc SYSTEM "../../clonk.dtd">
<?xml-stylesheet type="text/xsl" href="../../clonk.xsl"?>
<doc>
<title>#strict</title>
<h>#strict</h>
<part>
<text>Bei aktiviertem <code>#strict</code> werden einige
Altlasten der Engine ignoriert und es können unter anderem strengere Typüberprüfungen angesetzt
werden.</text>

<h id="Syntax">Deklaration</h>
<text>#strict muss als Direktive an den Anfang des Scriptes geschrieben werden. Bei #include und
#appendto gilt jeweils der Modus des Scriptes, zu dem includet/angehängt wird.</text>

<h>Auswirkungen</h>
<text><ul>
<li>Ein Funktionsaufruf auf denselben Funktionsnamen bedeutet immer einen rekursiven Aufruf</li>
<li><funclink>inherited</funclink>() und <funclink>_inherited</funclink>() werden verfügbar</li>
<li><funclink>goto</funclink>() impliziert kein <funclink>return</funclink>()</li>
<li><emlink href="script/Typechecks.html">Strengere Datentyp-Prüfung</emlink></li>
<li><funclink>CreateObject</funclink>() und <funclink>CreateConstruction</funclink>() überschreiben bei objektlokalem Aufruf nicht mehr den Besitzer</li>
</ul></text>
</part>
<h>#strict 2</h>
<part>
<text>Bei aktiviertem <code>#strict 2</code> werden einige
Altlasten der Engine ignoriert und es können unter anderem strengere Typüberprüfungen angesetzt
werden.</text>

<h>Deklaration</h>
<text><code>#strict 2</code> muss als Direktive an den Anfang des Scriptes geschrieben werden. Bei <code>#include</code> und
<code>#appendto</code> gilt jeweils der Modus des Scriptes, in dem die Funktion definiert wurde.</text>

<h>Auswirkungen</h>
<text><ul>
<li><code>&amp;&amp;</code> und <code>||</code> führen den zweiten Parameter nicht aus, wenn das Ergebnis schon nach Auswertung des ersten feststeht.</li>
<li><code>return</code>, <code>if</code> und <code>while</code> nehmen nur noch einen Parameter. Auch an anderen Stellen nimmt der Parser Ausdrücke nicht mehr an, vor denen früher nur gewarnt wurde.</li>
<li><code>==</code> und <code>!=</code> vergleichen nicht mehr die Identität von Werten, sondern ihren Inhalt und Typ. Beispielsweise gilt jetzt [1,2]==[2-1,2], "Hallo"=="Hallo" und CastInt(CLNK)!=CLNK.</li>
<li>Funktions- und Variablennamen dürfen nur noch die Zeichen a-z, A-Z und _, sowie 0-9 in der Mitte des Namens enthalten.</li>
<li><code>eq</code>, <code>ne</code>, <code>S=</code> gibt es nicht mehr. Man kann jetzt Funktionen und Variablen <code>eq</code> und <code>ne</code> nennen oder eine Variable namens <code>S</code> mit <code>S=42;</code> ändern.</li>
</ul></text>
</part>

	<h>#strict 3</h>
	<part>
		<text>Neu geschriebene Scripte sollten <code>#strict 3</code> sein. Dabei werden einige weitere
			Altlasten der Engine ignoriert, noch strengere Typüberprüfungen angesetzt und neue Sprachfeatures aktiviert.
			Scripte ohne <code>#strict 3</code> werden nur aus Gründen der Abwärtskompatibilität akzeptiert.</text>

		<h>Deklaration</h>
		<text><code>#strict 3</code> muss als Direktive an den Anfang des Scriptes geschrieben werden. Bei <code>#include</code> und
			<code>#appendto</code> gilt jeweils der Modus des Scriptes, in dem die Funktion definiert wurde.</text>

		<h>nil</h>
		<text>
			Mit <code>#strict 3</code> wird der neue Wert <code>nil</code> eingeführt.
			<code>nil</code> repräsentiert ungesetzte und undefinierte Werte und hat den Typ <code>any</code>.
			Weiters wird 0 und <code>false</code> nicht mehr implizit zu <code>any</code> konvertiert, sondern bleiben jetzt <code>int</code> bzw. <code>bool</code>.
			Dies ermöglicht unter anderem default-Werte für Parameter ungleich 0/<code>false</code> zu definieren, die trotzdem durch 0/<code>false</code> überschrieben werden können.
			<code>nil</code> ist ungleich jeder Wert anderen Typs inklusive 0 und <code>false</code>, es reicht also aus auf <code>x != nil</code> zu überprüfen, um festzustellen ob ein Wert gesetzt ist.
			<code>!nil</code> ist allerdings <code>true</code>.
		</text>
		<text>
			Da 0 und false nicht mehr <code>any</code> sind, können diese Werte nicht mehr zu anderen Typen wie <code>string</code>, <code>object</code>, <code>array</code> oder <code>map</code> konvertiert werden, was zu einem Error führen würde.
			Deshalb muss bei Funktionsargumenten dieser Typen auch nil statt 0 verwendet werden, um die jeweiligen Parameter als "ungesetzt" zu definieren.
		</text>

		<h>Der ?-Modifier</h>
		<text>
			Ebenfalls wird ein neuer Modifier eingeführt, der "sichere" Navigation erlaubt. ? wird dazu vor die Navigationsoperatoren gesetzt um eines der folgenden Konstrukte zu erhalten:
			<code>?.</code>, <code>?[i]</code>, <code>?-></code> oder <code>?->~</code>.
			Bei Verwendung des ?-Modifiers führen diese Zugriffe nicht zu einem Error, falls der zugrundeliegende Wert nil ist, sondern brechen den ganzen Ausdruck ab und lassen ihn als Ergebnis nil liefern.
			Da man bei Angabe dieses Modifiers annimmt, dass das Ergebnis des Ausdrucks manchmal nil werden kann, liefert der gesamte Ausdruck nie eine Referenz, sondern immer nur den dereferenzierten Wert. Das hat den Hintergrund, dass sonst bei Verwendung des Ausdruckergebnisses als Referenz unabdingbar Errors entstehen können, wodurch der Sinn des Modifiers zunichte gemacht wird.
		</text>

		<h>Weitere Auswirkungen</h>
		<text><ul>
			<li>Maps und die .-Zugriffssyntax werden verfügbar.</li>
			<li><emlink href="script/Funcs.html#Aufrufb">Aufrufberechtigungen</emlink> werden auch bei Verwendung der <code>-></code> Syntax überprüft, vorausgesetzt das Ziel-Script ist ebenfalls <code>#strict 3</code> oder höher.</li>
			<li><code>global-></code> und <code>global->~</code> werden verfügbar.</li>
			<li><code>false != 0</code> und <code>true != 1</code></li>
		</ul></text>
	</part>
	<author>Sven2</author><date>Juli 2001</date>
	<author>Günther</author><date>Dezember 2007</date>
	<author>Der Tod</author><date>Oktober 2019</date>
</doc>
